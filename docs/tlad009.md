# Background to the Rationale for SPaDE

## Contents

- [Introduction](#introduction)

## Introduction

I would like to give the clearest possible account of the rationale behind the SPaDE project.

A difficulty in doing that is that such an account would at least partly autobiographical, and I'm pretty keen to avoid talking about myself any more than is absolutely necessary.

So I will try to talk about the progression of the key ideas in a concise way abstracted away from any unnecessary personal detail.

## First Ideas

The ideas behind SPaDE have been developing almost as long as the very earliest independent ideas which I have ever had, so I think it is worth mentioning those earliest ideas.

- [On God](#on-god)
- [Computers](#computers)

### On God

The very first independent thinking I recall resulted from my being obliged to attend a church service every Sunday through my first year at grammar school (age 11-12).
Many of those services included a sermon, and to understand them one needed to grasp the concept of God.
I tried hard, but failed, and thenceforth considered myself an atheist.

The relevance of this to SPaDE is in the as yet trifling normative aspect hinted at by adding the adjective "benign" to the description of the kind of self-proliferating intelligent systems which SPaDE is intended to help design and construct.
I do attach importance to the normative aspect of the project, albeit for practical reasons.
Morality has evolved, and it should therefore be presumed that altruism is (as one might expect) advantageous, and therefore that any attempt to anticipate the future must include normative elements.
Part of the advantage thus obtained is in making more attractive the SPaDE project and its ilk and thereby increasing its adoption and influence.

But this does not, in my view, require any kind of belief in God, or any other supernatural entity, which I suspect would be counterproductive.
I don't intend to say anything further about the existence or otherwise of God, and the development of the normative side of SPaDE will make no reference to divinities.

### Computers

I learned almost nothing about computers at school.
We had one lesson in the sixth for in which Pegasus autocode was explained, one homework assignment to write a program of our choice, and a day trip to the University of Bradford to punch up the program on 5-track paper tape and feed it into the computer.

In the sixth form I did A-level Mathematics, Further Mathematics and Physics.
But I was put in for the Cambridge Entrance Examination and applied to Cambridge University to read Mechanical Sciences.
The entrance exam did not confine itself to the curriculum I had studied, and included a question asking for the design of a half-adder, which I answered, though I have no memory of how I knew the answer.

To apply to Cambridge in those days, you had to nominate it as your first choice, which I did, though really it was not.
My preference would really have been to go to the only University in the UK at the time, which offered a degree course in Computer Science, namely Manchester University.

I was offered a place at Cambridge, and also at Manchester (which was probably even more competitive at the time for that course).
I went to Cambridge, which on its face was a mistake.
I didn't stay long.

Luckily the engineering department was more enlightened about computing than the Mathematics department (which exposed its undergraduates to nothing more sophisticated than a hand cranked calculator).
It was here that I first became acquainted with the ideas of Alan Turing (who had been personally known to my tutor), first became interested in AI, and had a first original idea in relation to AI.

The Engineering department installed that year an IBM 11/30 which was to be shared between teaching undergraduates to program and doing research.
The machine could be programmed (via 8-track paper tape) in Fortran II or in assembly language, but undergraduates were not permitted to use assembly language.

In my explorations I discovered how I could assemble machine code in a Fortran array and then get the program to execute it.

My first interesting idea about AI resulted from noticing that a program I wrote to allow the console to be used (instead of the more heavily used flexowriters) for editing a paper tape, produced a tape much longer than the original (because tabs were unintentionaly converted to multiple spaces).
I thought about ways of compressing the content of a tape and concluded that if one could analyse a body of knowledge to get a perfect compression of its sentences, then the inversion of that compression algorithm would be a program which would take random seeds and output only true sentences.
It was a curious thought, I didn't imagine it could be done.

I see now there is a trivial but useless algorithm, but it still feels like a bit of a comment on L
