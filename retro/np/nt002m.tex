\def\VCDate{2025/06/04}\def\VCVersion{2e6554f}
\ignore{
\begin{GFTSHOW}{Text dumped to file nt002i.tex}
\+\Backslash{}hypersetup\{pdfkeywords=RogerBishopJones\}\\
\+\\
\+Last Change \$ \$Date: 2025:06:04 \$ \$\\
\+\\
\+\$ \$Id: nt002i.doc  \$ \$\\
\end{GFTSHOW}
}%ignore

This is at first a copy of t050, a treatmemt of combinatory logic in HOL, and will be massaged into the first stage in a formalisation of HOL which is intended to play an important role in progressing some new ideas about future deductive technology based on the HOL logic.

\begin{GFT}{SML}
\+open\_theory "misc3";\\
\+force\_new\_theory "\PrNL{}nphol\PrNN{}";\\
\+force\_new\_pc \PrNL{}"'nphol"\PrNN{};\\
\+merge\_pcs ["'savedthm\_cs\_\MMM{\exists}\_proof"] "'nphol";\\
\end{GFT}
\begin{GFT}{SML}
\+set\_merge\_pcs ["misc31", "'icl"];\\
\end{GFT}

\section{Reduction}

In this section I deal with matters which do not in the hol4 treatment depend upon the type of combinatory terms, and some matters which in the hol4 treatment do but need not.
The latter requires some restructuring of the proof strategy

\subsection{Diamond Preserved by RTC}

In this section we obtain the result that the recursive transitive closure of a relation satisfying the diamond property also satisfies that property.

The proof in the hol4 version is slick because RTC is redefined using a package for defining relations which delivers some nice induction principles.

\begin{HOLConst}
\+\PrNM{} \PrNL{}confluent\PrNN{}: ('a \MMM{\rightarrow} 'a  \MMM{\rightarrow} BOOL) \MMM{\rightarrow} BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}R\MMM{\bullet} confluent R \MMM{\Leftrightarrow} \MMM{\forall}x y z\MMM{\bullet} rtc R x y \MMM{\land} rtc R x z \MMM{\Rightarrow}\\
\+\PrNM{}             \MMM{\exists}u\MMM{\bullet} rtc R y u \MMM{\land} rtc R z u\\
\end{HOLConst}

\begin{HOLConst}
\+\PrNM{} \PrNL{}normform\PrNN{}: ('a \MMM{\rightarrow} 'a  \MMM{\rightarrow} BOOL) \MMM{\rightarrow} 'a \MMM{\rightarrow}BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}R x\MMM{\bullet} normform R x \MMM{\Leftrightarrow} \MMM{\forall}y\MMM{\bullet} \MMM{\lnot} R x y\\
\end{HOLConst}

\begin{GFT}{}
\+\PrNL{}confluent\_normforms\_unique\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} R\MMM{\bullet} confluent R \MMM{\Rightarrow}\\
\+		(\MMM{\forall} x y z\MMM{\bullet} rtc R x y \MMM{\land} normform R y \MMM{\land} rtc R x z \MMM{\land} normform R z\\
\+		\MMM{\Rightarrow} y = z)\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val confluent\_def = get\_spec \PrKM{}confluent\PrKO{};\\
\+val normform\_def = get\_spec \PrKM{}normform\PrKO{};\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}R\MMM{\bullet} confluent R \MMM{\Rightarrow}\\
\+        \MMM{\forall}x y z\MMM{\bullet} rtc R x y \MMM{\land} normform R y \MMM{\land} rtc R x z \MMM{\land} normform R z\\
\+                  \MMM{\Rightarrow} (y = z)\PrKO{});\\
\+a (rewrite\_tac[confluent\_def, normform\_def]\\
\+	THEN REPEAT strip\_tac);\\
\+a (LIST\_SPEC\_NTH\_ASM\_T 5 [\PrKM{}x\PrKO{}, \PrKM{}y\PrKO{}, \PrKM{}z\PrKO{}] strip\_asm\_tac);\\
\+a (REPEAT\_N 2 (POP\_ASM\_T ante\_tac)\\
\+	THEN once\_rewrite\_tac[rtc\_cases]\\
\+	THEN REPEAT strip\_tac\\
\+	THEN\_TRY all\_asm\_ufc\_tac[]\\
\+	THEN (SYM\_ASMS\_T rewrite\_tac));\\
\+val confluent\_normforms\_unique = save\_pop\_thm "confluent\_normforms\_unique";\\
\end{GFT}
}%ignore


\begin{HOLConst}
\+\PrNM{} \PrNL{}diamond\PrNN{}: ('a \MMM{\rightarrow} 'a  \MMM{\rightarrow} BOOL) \MMM{\rightarrow} BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}R\MMM{\bullet} diamond R = \MMM{\forall}x y z\MMM{\bullet} R x y \MMM{\land} R x z \MMM{\Rightarrow} \MMM{\exists}u\MMM{\bullet} R y u \MMM{\land} R z u\\
\end{HOLConst}

\begin{GFT}{}
\+\PrNL{}confluent\_diamond\_rtc\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} R\MMM{\bullet} confluent R \MMM{\Leftrightarrow} diamond (rtc R)\\
\+\\
\+\PrNL{}R\_rtc\_diamond\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} R\MMM{\bullet} diamond R \MMM{\Rightarrow} (\MMM{\forall} x p\MMM{\bullet} rtc R x p \MMM{\Rightarrow}\\
\+		(\MMM{\forall} z\MMM{\bullet} R x z \MMM{\Rightarrow} (\MMM{\exists} u\MMM{\bullet} rtc R p u \MMM{\land} rtc R z u)))\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val diamond\_def = get\_spec \PrKM{}diamond\PrKO{};\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}R\MMM{\bullet} confluent R = diamond (rtc R)\PrKO{});\\
\+a (rewrite\_tac[confluent\_def, diamond\_def]);\\
\+val confluent\_diamond\_rtc = save\_pop\_thm "confluent\_diamond\_rtc";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}R\MMM{\bullet} diamond R \MMM{\Rightarrow}\\
\+         \MMM{\forall}x p\MMM{\bullet} rtc R x p \MMM{\Rightarrow}\\
\+               \MMM{\forall}z\MMM{\bullet} R x z \MMM{\Rightarrow}\\
\+                   \MMM{\exists}u\MMM{\bullet} rtc R p u \MMM{\land} rtc R z u\PrKO{});\\
\+a (\MMM{\forall}\_tac THEN strip\_tac);\\
\+a (rtc\_ind\_tac THEN REPEAT strip\_tac);\\
\+(* *** Goal "1" *** *)\\
\+a (fc\_tac[diamond\_def]);\\
\+a (fc\_tac [rtc\_incr\_thm]);\\
\+a (\MMM{\exists}\_tac \PrKM{}z\PrKO{} THEN asm\_rewrite\_tac[rtc\_def]);\\
\+(* *** Goal "2" *** *)\\
\+a (fc\_tac[diamond\_def]);\\
\+a (all\_asm\_fc\_tac[]);\\
\+a (spec\_nth\_asm\_tac 9 \PrKM{}u'\PrKO{});\\
\+a (all\_fc\_tac [rtc\_incr\_thm]);\\
\+a (all\_fc\_tac [tran\_rtc\_thm2]);\\
\+a (\MMM{\exists}\_tac \PrKM{}u''''\PrKO{} THEN asm\_rewrite\_tac[]);\\
\+val R\_rtc\_diamond = save\_pop\_thm "R\_rtc\_diamond";\\
\end{GFT}
}%ignore

$RTC\_RTC$ is the transitivity of reflexive transitive closure, which we have as $tran\_rtc\_thm2$.

\begin{GFT}{}
\+\PrNL{}diamond\_RTC\_lemma\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} R\MMM{\bullet} diamond R \MMM{\Rightarrow} (\MMM{\forall} x y\MMM{\bullet} rtc R x y\\
\+		\MMM{\Rightarrow} (\MMM{\forall} z\MMM{\bullet} rtc R x z \MMM{\Rightarrow} (\MMM{\exists} u\MMM{\bullet} rtc R y u \MMM{\land} rtc R z u)))\\
\+\\
\+\PrNL{}diamond\_RTC\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} R\MMM{\bullet} diamond R \MMM{\Rightarrow} diamond (rtc R)\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+set\_goal([], \PrKM{}\MMM{\forall}R\MMM{\bullet} diamond R \MMM{\Rightarrow}\\
\+       \MMM{\forall}x y\MMM{\bullet} rtc R x y \MMM{\Rightarrow} \MMM{\forall}z\MMM{\bullet} rtc R x z \MMM{\Rightarrow}\\
\+                               \MMM{\exists}u\MMM{\bullet} rtc R y u \MMM{\land} rtc R z u\PrKO{});\\
\+a (strip\_tac THEN strip\_tac);\\
\+a (rtc\_strongind\_tac THEN REPEAT strip\_tac);\\
\+(* *** Goal "1" *** *)\\
\+a (\MMM{\exists}\_tac \PrKM{}z\PrKO{} THEN asm\_rewrite\_tac [rtc\_rules]);\\
\+(* *** Goal "2" *** *)\\
\+a (all\_ufc\_tac[R\_rtc\_diamond]);\\
\+a (all\_asm\_ufc\_tac[]);\\
\+a (all\_ufc\_tac[tran\_rtc\_thm2]);\\
\+a (\MMM{\exists}\_tac \PrKM{}u'\PrKO{} THEN contr\_tac);\\
\+val diamond\_RTC\_lemma = save\_pop\_thm "diamond\_RTC\_lemma";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}R\MMM{\bullet} diamond R \MMM{\Rightarrow} diamond (rtc R)\PrKO{});\\
\+a (REPEAT strip\_tac\\
\+	THEN rewrite\_tac [diamond\_def]\\
\+	THEN REPEAT strip\_tac\\
\+	THEN all\_fc\_tac [diamond\_RTC\_lemma]);\\
\+a (\MMM{\exists}\_tac \PrKM{}u'\PrKO{} THEN contr\_tac);\\
\+val diamond\_RTC = save\_pop\_thm "diamond\_RTC";\\
\end{GFT}
}%ignore




\subsection{Further Results about Reduction Relations}

In the hol4 proof reduction is defined over combinatory terms using a relation definition package which results in the following definition (this is the result of a modified notion admitting more combinatory constants):

\begin{GFT}{}
\+    redn\_def\\
\+    |- \$--> =\\
\+       (\MMM{\lambda}a0 a1.\\
\+          \MMM{\forall}-->' .\\
\+            (\MMM{\forall}a0 a1.\\
\+               (\MMM{\exists}x y f. (a0 = f \# x) \MMM{\land} (a1 = f \# y) \MMM{\land} -->' x y) \MMM{\lor}\\
\+               (\MMM{\exists}f g x. (a0 = f \# x) \MMM{\land} (a1 = g \# x) \MMM{\land} -->' f g) \MMM{\lor}\\
\+               (\MMM{\exists}y. a0 = C 0 \# a1 \# y) \MMM{\lor}\\
\+               (\MMM{\exists}f g x.\\
\+                  (a0 = C 1 \# f \# g \# x) \MMM{\land} (a1 = f \# x \# (g \# x))) \MMM{\lor}\\
\+               (\MMM{\exists}x. (a0 = C 2 \# x \# x) \MMM{\land} (a1 = C 0)) \MMM{\Rightarrow}\\
\+               -->' a0 a1) \MMM{\Rightarrow}\\
\+            -->' a0 a1)\\
\end{GFT}

Of the various parts in this definition, the first two make this a congruence relation, i.e. reductions on parts yeild reductions on the whole, the third is the primitive reduction for K, the fourth for S, the fifth for Q.
These are wrapped up to assert that the defined relation is the intersection of all relations closed under these rules.

The


So the natural way to proceed in the absence of the rule-based relation definition facility in hol4 is to define the primitive relations for each combinator, combine them (take the union or disjunction), form the congruence and take the transitive closure.


\section{Combinatory Terms}

\subsection{Introduction}

In hol4 the syntax of combinatory logic is give as a single line definition of a recursive datatype.
We can't do this in ProofPower, datatypes have to be manually cranked.
This section replicates that process, and aims to replicate pretty closely what hol4 produces for that datatype.

I did first of all modify the type to allow any number of combinatory constants after which the definition read:

\begin{GFT}{hol4}
\+val \_ = Hol\_datatype `CT = C of num | \# of CT => CT`;\\
\end{GFT}

The theory resulting from that datatype definition is as follows:

\begin{GFT}{hol4}
\+Theory: cl\\
\+\\
\+Parents:\\
\+    list\\
\+\\
\+Type constants:\\
\+    CT 0\\
\+\\
\+Term constants:\\
\+    \#    :CT -> CT -> CT\\
\+    C    :num -> CT\\
\+    CT\_case    :(num -> \MMM{\alpha}) -> (CT -> CT -> \MMM{\alpha}) -> CT -> \MMM{\alpha}\\
\+    CT\_size    :CT -> num\\
\+\\
\+Definitions:\\
\+    CT\_TY\_DEF\\
\+    |- \MMM{\exists}rep.\\
\+         TYPE\_DEFINITION\\
\+           (\MMM{\lambda}a0'.\\
\+              \MMM{\forall}'CT' .\\
\+                (\MMM{\forall}a0'.\\
\+                   (\MMM{\exists}a.\\
\+                      a0' =\\
\+                      (\MMM{\lambda}a. ind\_type\$CONSTR 0 a (\MMM{\lambda}n. ind\_type\$BOTTOM))\\
\+                        a) \MMM{\lor}\\
\+                   (\MMM{\exists}a0 a1.\\
\+                      (a0' =\\
\+                       (\MMM{\lambda}a0 a1.\\
\+                          ind\_type\$CONSTR (SUC 0) ARB\\
\+                            (ind\_type\$FCONS a0\\
\+                               (ind\_type\$FCONS a1\\
\+                                  (\MMM{\lambda}n. ind\_type\$BOTTOM)))) a0 a1) \MMM{\land}\\
\+                      'CT' a0 \MMM{\land} 'CT' a1) \MMM{\Rightarrow}\\
\+                   'CT' a0') \MMM{\Rightarrow}\\
\+                'CT' a0') rep\\
\+    CT\_case\_def\\
\+    |- (\MMM{\forall}f f1 a. CT\_case f f1 (C a) = f a) \MMM{\land}\\
\+       \MMM{\forall}f f1 a0 a1. CT\_case f f1 (\# a0 a1) = f1 a0 a1\\
\+    CT\_size\_def\\
\+    |- (\MMM{\forall}a. CT\_size (C a) = 1 + a) \MMM{\land}\\
\+       \MMM{\forall}a0 a1. CT\_size (\# a0 a1) = 1 + (CT\_size a0 + CT\_size a1)\\
\+\\
\+Theorems:\\
\+    datatype\_CT  |- DATATYPE (CT C \#)\\
\+    CT\_11\\
\+    |- (\MMM{\forall}a a'. (C a = C a') \MMM{\Leftrightarrow} (a = a')) \MMM{\land}\\
\+       \MMM{\forall}a0 a1 a0' a1'. (\# a0 a1 = \# a0' a1') \MMM{\Leftrightarrow} (a0 = a0') \MMM{\land} (a1 = a1')\\
\+    CT\_distinct  |- \MMM{\forall}a1 a0 a. C a \MMM{\neq} \# a0 a1\\
\+    CT\_case\_cong\\
\+    |- \MMM{\forall}M M' f f1.\\
\+         (M = M') \MMM{\land} (\MMM{\forall}a. (M' = C a) \MMM{\Rightarrow} (f a = f' a)) \MMM{\land}\\
\+         (\MMM{\forall}a0 a1. (M' = \# a0 a1) \MMM{\Rightarrow} (f1 a0 a1 = f1' a0 a1)) \MMM{\Rightarrow}\\
\+         (CT\_case f f1 M = CT\_case f' f1' M')\\
\+    CT\_nchotomy  |- \MMM{\forall}CC. (\MMM{\exists}n. CC = C n) \MMM{\lor} \MMM{\exists}C C0. CC = \# C C0\\
\+    CT\_Axiom\\
\+    |- \MMM{\forall}f0 f1.\\
\+         \MMM{\exists}fn.\\
\+           (\MMM{\forall}a. fn (C a) = f0 a) \MMM{\land}\\
\+           \MMM{\forall}a0 a1. fn (\# a0 a1) = f1 a0 a1 (fn a0) (fn a1)\\
\+    CT\_induction\\
\+    |- \MMM{\forall}P. (\MMM{\forall}n. P (C n)) \MMM{\land} (\MMM{\forall}C C0. P C \MMM{\land} P C0 \MMM{\Rightarrow} P (\# C C0)) \MMM{\Rightarrow} \MMM{\forall}C. P C\\
\end{GFT}

In this section I aim to replicate this quite closely, though using a different representation.
I am assuming that once this is done here, there will be no further need to refer to the representing type.

\subsection{Introducing the type CT}

The natural way to hand crank such a datatype in ProofPower HOL would be to use the theory of trees in Arthan's mathematical examples as a representation type.
However, I am more familiar with using the domain of an axiomatic set theory so it will be slightly easier for me to do that.

I don't define the constructors over the representation type since they are simple enough to write out, instead I go straight to defining the closure conditions on the set of representatives.

There are two constructors, a constant constructor and an application constructor.
There are countably many constants named by natural numbers, and tagged by zero to distinguish them from applications.
An application is constructed from two combinators and is tagged by 1.

The closure condition is:

\begin{HOLConst}
\+\PrNM{} \PrNL{}CTrepClosed\PrNN{}: (ONE GSU \MMM{\rightarrow} BOOL) \MMM{\rightarrow} BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall} s\MMM{\bullet} CTrepClosed s \MMM{\Leftrightarrow} (\MMM{\forall}n\MMM{\bullet} s (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n))\\
\+\PrNM{}	\MMM{\land} (\MMM{\forall}f a\MMM{\bullet} s f \MMM{\land} s a \MMM{\Rightarrow} s (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} (f \MMM{\mapsto}\PrIJ{u} a)))\\
\end{HOLConst}

The property of being a combinatory term is then the smallest property which is \emph{CTrepClosed}.

\begin{HOLConst}
\+\PrNM{} \PrNL{}CTsyntax\PrNN{} : ONE GSU \MMM{\rightarrow} BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}s\MMM{\bullet} CTsyntax s = \MMM{\forall}t \MMM{\bullet} CTrepClosed t \MMM{\Rightarrow} t s\\
\end{HOLConst}

The following theorems about the representation are helpful in proving related result for the new type:

\begin{GFT}{}
\+\PrNL{}CTrepclosed\_CTsyntax\_lemma1\PrNN{} =\\
\+	\MMM{\Zthm} CTrepClosed CTsyntax\\
\+\\
\+\PrNL{}CTrepclosed\_CTsyntax\_thm\PrNN{} =\\
\+	\MMM{\Zthm} (\MMM{\forall}n\MMM{\bullet} CTsyntax (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n))\\
\+       \MMM{\land} (\MMM{\forall}f a\MMM{\bullet} CTsyntax f \MMM{\land} CTsyntax a \MMM{\Rightarrow} CTsyntax (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} f \MMM{\mapsto}\PrIJ{u} a))\\
\end{GFT}
\begin{GFT}{}
\+\PrNL{}CTrepclosed\_CTsyntax\_lemma2\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall}s\MMM{\bullet} CTrepClosed s \MMM{\Rightarrow} (\MMM{\forall} t\MMM{\bullet} CTsyntax t \MMM{\Rightarrow} s t)\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val CTrepClosed\_def = get\_spec \PrKM{}CTrepClosed\PrKO{};\\
\+val CTsyntax\_def = get\_spec \PrKM{}CTsyntax\PrKO{};\\
\+\\
\+set\_goal([], \PrKM{}CTrepClosed CTsyntax\PrKO{});\\
\+val \_ = a (rewrite\_tac [CTsyntax\_def, CTrepClosed\_def]\\
\+	THEN REPEAT strip\_tac\\
\+	THEN REPEAT\_N 3 (asm\_ufc\_tac[])\\
\+	THEN asm\_rewrite\_tac[]);\\
\+val CTrepclosed\_CTsyntax\_lemma1 = save\_pop\_thm "CTrepclosed\_CTsyntax\_lemma1";\\
\+\\
\+val CTrepclosed\_CTsyntax\_thm = save\_thm ("CTrepclosed\_CTsyntax\_thm",\\
\+	pure\_rewrite\_rule [get\_spec \PrKM{}CTrepClosed\PrKO{}] CTrepclosed\_CTsyntax\_lemma1);\\
\+\\
\+local val \_ = set\_goal([], \PrKM{}\MMM{\forall} s\MMM{\bullet} CTrepClosed s \MMM{\Rightarrow} \MMM{\forall}t\MMM{\bullet} CTsyntax t \MMM{\Rightarrow} s t\PrKO{});\\
\+val \_ = a (rewrite\_tac [CTsyntax\_def]\\
\+	THEN prove\_tac[]);\\
\+in val CTrepclosed\_CTsyntax\_lemma2 = save\_pop\_thm "CTrepclosed\_CTsyntax\_lemma2";\\
\+end;\\
\end{GFT}
}%ignore

\begin{GFT}{}
\+\PrNL{}CTsyntax\_cases\_thm\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall}c\MMM{\bullet} CTsyntax c\\
\+		\MMM{\Rightarrow} (\MMM{\exists} n\MMM{\bullet} c = Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n)\\
\+		\MMM{\lor} (\MMM{\exists} f a\MMM{\bullet} CTsyntax f \MMM{\land} CTsyntax a \MMM{\land} c = Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} f \MMM{\mapsto}\PrIJ{u} a)\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+set\_goal([], \PrKM{}\MMM{\forall}c\MMM{\bullet} CTsyntax c \MMM{\Rightarrow}\\
\+		(\MMM{\exists}n\MMM{\bullet} c = Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n)\\
\+	\MMM{\lor}	(\MMM{\exists}f a\MMM{\bullet} CTsyntax f \MMM{\land} CTsyntax a \MMM{\land} c = (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} f \MMM{\mapsto}\PrIJ{u} a))\PrKO{});\\
\+a (lemma\_tac \PrKM{}CTrepClosed (\MMM{\lambda}c\MMM{\bullet} (\MMM{\exists}n\MMM{\bullet} c = Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n)\\
\+	\MMM{\lor}	(\MMM{\exists}f a\MMM{\bullet} CTsyntax f \MMM{\land} CTsyntax a \MMM{\land} c = (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} f \MMM{\mapsto}\PrIJ{u} a)))\PrKO{}\\
\+	THEN1 (rewrite\_tac[CTrepClosed\_def]\\
\+		THEN REPEAT strip\_tac));\\
\+(* *** Goal "1" *** *)\\
\+a (prove\_\MMM{\exists}\_tac);\\
\+(* *** Goal "2" *** *)\\
\+a (asm\_prove\_\MMM{\exists}\_tac THEN asm\_rewrite\_tac[CTrepclosed\_CTsyntax\_thm]);\\
\+(* *** Goal "3" *** *)\\
\+a (asm\_prove\_\MMM{\exists}\_tac\\
\+	THEN asm\_rewrite\_tac[]\\
\+	THEN ALL\_FC\_T rewrite\_tac [CTrepclosed\_CTsyntax\_thm]\\
\+	THEN rewrite\_tac[CTrepclosed\_CTsyntax\_thm]);\\
\+(* *** Goal "4" *** *)\\
\+a (asm\_prove\_\MMM{\exists}\_tac\\
\+	THEN asm\_rewrite\_tac[]\\
\+	THEN ALL\_FC\_T rewrite\_tac [CTrepclosed\_CTsyntax\_thm]\\
\+	THEN rewrite\_tac[CTrepclosed\_CTsyntax\_thm]);\\
\+(* *** Goal "5" *** *)\\
\+a (asm\_prove\_\MMM{\exists}\_tac\\
\+	THEN asm\_rewrite\_tac[]\\
\+	THEN ALL\_FC\_T rewrite\_tac [CTrepclosed\_CTsyntax\_thm]\\
\+	THEN rewrite\_tac[CTrepclosed\_CTsyntax\_thm]);\\
\+(* *** Goal "6" *** *)\\
\+a (REPEAT\_N 2 strip\_tac);\\
\+a (fc\_tac [CTsyntax\_def]);\\
\+a (all\_asm\_fc\_tac[]);\\
\+a (POP\_ASM\_T ante\_tac THEN rewrite\_tac[]);\\
\+val CTsyntax\_cases\_thm = save\_pop\_thm "CTsyntax\_cases\_thm";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\exists}c\MMM{\bullet} CTsyntax c\PrKO{});\\
\+a (\MMM{\exists}\_tac \PrKM{}Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} 0\PrKO{}\\
\+	THEN rewrite\_tac [CTsyntax\_def, CTrepClosed\_def]\\
\+	THEN REPEAT strip\_tac\\
\+	THEN asm\_rewrite\_tac[]);\\
\+val CTsyntax\_nonempty = pop\_thm();\\
\end{GFT}
}%ignore

To introduce the new type we must prove that \emph{CTsyntax} is inhabited: 

\begin{GFT}{}
\+\PrNL{}CTsyntax\_nonempty\PrNN{} = \\
\+	\MMM{\Zthm} \MMM{\exists}c\MMM{\bullet} CTsyntax c\\
\end{GFT}

The type \emph{CT} is then introduced as follows:

\begin{GFT}{SML}
\+val CT\_type\_defn\_thm = new\_type\_defn(["CT"], "CT", [], CTsyntax\_nonempty);\\
\end{GFT}

Which gives the following result:
\begin{GFT}{}
\+\PrNL{}CT\_type\_defn\_thm\PrNN{} = \MMM{\Zthm} \MMM{\exists} f\MMM{\bullet} TypeDefn CTsyntax f\\
\end{GFT}

From which we can derive:

\begin{GFT}{}
\+\PrNL{}CT\_type\_lemma2\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\exists} abs rep\MMM{\bullet} (\MMM{\forall} a\MMM{\bullet} abs (rep a) = a)\\
\+         \MMM{\land} (\MMM{\forall} r\MMM{\bullet} CTsyntax r \MMM{\Leftrightarrow} rep (abs r) = r)\\
\+         \MMM{\land} OneOne rep\\
\+         \MMM{\land} (\MMM{\forall} a\MMM{\bullet} CTsyntax (rep a))\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val [CT\_type\_lemma2] = fc\_rule [type\_defn\_lemma4] [CT\_type\_defn\_thm];\\
\end{GFT}
}%ignore

\subsection{Primitive Constructors over CT}

I could manage without defining the following mappings between the new type and its representations , but its easier to define them.

\ignore{
\begin{GFT}{SML}
\+set\_goal([], \PrKM{}\MMM{\exists}(CTabs:ONE GSU \MMM{\rightarrow} CT) (CTrep:CT \MMM{\rightarrow} ONE GSU)\MMM{\bullet}\\
\+	(\MMM{\forall} a\MMM{\bullet} CTabs (CTrep a) = a)\\
\+     \MMM{\land} (\MMM{\forall} r\MMM{\bullet} CTsyntax r \MMM{\Leftrightarrow} CTrep (CTabs r) = r)\\
\+     \MMM{\land} OneOne CTrep\\
\+     \MMM{\land} (\MMM{\forall} a\MMM{\bullet} CTsyntax (CTrep a))\PrKO{});\\
\+a (strip\_asm\_tac CT\_type\_lemma2);\\
\+a (\MMM{\exists}\_tac \PrKM{}abs\PrKO{} THEN \MMM{\exists}\_tac \PrKM{}rep\PrKO{} THEN asm\_rewrite\_tac[]);\\
\+save\_cs\_\MMM{\exists}\_thm(pop\_thm());\\
\end{GFT}
}%ignore

\begin{HOLConst}
\+\PrNM{} \PrNL{}CTabs\PrNN{}: ONE GSU \MMM{\rightarrow} CT;\\
\+\PrNM{} \PrNL{}CTrep\PrNN{}: CT \MMM{\rightarrow} ONE GSU\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{}	(\MMM{\forall} a\MMM{\bullet} CTabs (CTrep a) = a)\\
\+\PrNM{}     \MMM{\land} (\MMM{\forall} r\MMM{\bullet} CTsyntax r \MMM{\Leftrightarrow} CTrep (CTabs r) = r)\\
\+\PrNM{}     \MMM{\land} OneOne CTrep\\
\+\PrNM{}     \MMM{\land} (\MMM{\forall} a\MMM{\bullet} CTsyntax (CTrep a))\\
\end{HOLConst}


There will be two constructors one for constants and one for applications.
Applications are infix.

\begin{GFT}{SML}
\+declare\_infix(1000, "\PrIJ{c}");\\
\end{GFT}

\begin{HOLConst}
\+\PrNM{} \PrNL{}\$\PrIJ{c}\PrNN{}: CT \MMM{\rightarrow} CT \MMM{\rightarrow} CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}s t\MMM{\bullet} s \PrIJ{c} t = CTabs (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} (CTrep s) \MMM{\mapsto}\PrIJ{u} (CTrep t))\\
\end{HOLConst}

\begin{HOLConst}
\+\PrNM{} \PrNL{}C\PrNN{}: \PrOO{} \MMM{\rightarrow} CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}s\MMM{\bullet} C s = CTabs(Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} (Nat\PrIJ{u} s))\\
\end{HOLConst}

\begin{GFT}{}
\+\PrNL{}CT\_cases\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} t\MMM{\bullet} (\MMM{\exists} n\MMM{\bullet} t = C n) \MMM{\lor} (\MMM{\exists} c1 c2\MMM{\bullet} t = c1 \PrIJ{c} c2)\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val CTrep\_def = get\_spec \PrKM{}CTrep\PrKO{};\\
\+val \PrIJ{c}\_def = get\_spec \PrKM{}\$\PrIJ{c}\PrKO{};\\
\+val C\_def = get\_spec \PrKM{}C\PrKO{};\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}t\MMM{\bullet} (\MMM{\exists}n\MMM{\bullet} t = C n) \MMM{\lor} (\MMM{\exists}c1 c2\MMM{\bullet} t = c1 \PrIJ{c} c2)\PrKO{});\\
\+a (strip\_tac);\\
\+a (strip\_asm\_tac (\MMM{\forall}\_elim \PrKM{}CTrep t\PrKO{} CTsyntax\_cases\_thm));\\
\+(* *** Goal "1" *** *)\\
\+a (POP\_ASM\_T ante\_tac THEN rewrite\_tac [CTrep\_def]);\\
\+(* *** Goal "2" *** *)\\
\+a (\MMM{\lor}\_left\_tac THEN \MMM{\exists}\_tac \PrKM{}n\PrKO{} THEN asm\_rewrite\_tac[C\_def]);\\
\+a (LEMMA\_T \PrKM{}CTabs(Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n) = CTabs(CTrep t)\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+a (rewrite\_tac[CTrep\_def]);\\
\+(* *** Goal "3" *** *)\\
\+a (\MMM{\lor}\_right\_tac THEN \MMM{\exists}\_tac \PrKM{}CTabs f\PrKO{} THEN \MMM{\exists}\_tac \PrKM{}CTabs a\PrKO{}\\
\+	THEN asm\_rewrite\_tac[\PrIJ{c}\_def]);\\
\+a (LEMMA\_T \PrKM{}CTabs(Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep (CTabs f) \MMM{\mapsto}\PrIJ{u} CTrep (CTabs a)) = CTabs(CTrep t)\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+a (FC\_T rewrite\_tac [CTrep\_def]);\\
\+(* *** Goal "3.2" *** *)\\
\+a (rewrite\_tac [CTrep\_def]);\\
\+val CT\_cases = save\_pop\_thm "CT\_cases";\\
\end{GFT}
}%ignore

\subsection{Induction and Recursion}

Now we obtain a principle of induction for reasoning about these combinatory terms and a recursion theorem to justify definitions over the terms by pattern matching recursion.

We can derive a well-founded ordering for combinatory terms from the well-foundedness of membership over the sets used to represent the terms.
This provides a first method of proof by induction over the combinatory terms which is used to prove the induction principle produced by hol4.

\begin{GFT}{}
\+\PrNL{}wf\_CT\_thm\PrNN{} =\\
\+	\MMM{\Zthm} well\_founded (\MMM{\lambda} x y\MMM{\bullet} CTrep x \MMM{\in}\PrIJ{u} CTrep y)\\
\+\PrNL{}tc\MMM{\in}\PrIJ{u}\_rep\_\PrIJ{c}\_lemma\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} c1 c2\MMM{\bullet} CTrep c1 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2)\\
\+		\MMM{\land} CTrep c2 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2)\\
\+\PrNL{}CT\_induction\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} P\MMM{\bullet} (\MMM{\forall} n\MMM{\bullet} P (C n)) \MMM{\land} (\MMM{\forall} c c0\MMM{\bullet} P c \MMM{\land} P c0 \MMM{\Rightarrow} P (c \PrIJ{c} c0))\\
\+		\MMM{\Rightarrow} (\MMM{\forall} c\MMM{\bullet} P c)\\
\+\PrNL{}CT\_axiom\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} f0 f1\MMM{\bullet} \MMM{\exists} fn\MMM{\bullet}\\
\+		(\MMM{\forall} a\MMM{\bullet} fn (C a) = f0 a)\\
\+           \MMM{\land}	(\MMM{\forall} a0 a1\MMM{\bullet} fn (a0 \PrIJ{c} a1) = f1 a0 a1 (fn a0) (fn a1))\\
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+set\_goal([], \PrKM{}well\_founded(DerivedOrder CTrep (\$\MMM{\in}\PrIJ{u}\PrJL{+}:ONE GSU \MMM{\rightarrow} ONE GSU \MMM{\rightarrow} BOOL))\PrKO{});\\
\+a (rewrite\_tac [\MMM{\forall}\_elim \PrKM{}CTrep\PrKO{} (\MMM{\Rightarrow}\_elim (\MMM{\forall}\_elim \PrKM{}\$\MMM{\in}\PrIJ{u}\PrJL{+}:ONE GSU \MMM{\rightarrow} ONE GSU \MMM{\rightarrow} BOOL\PrKO{} wf\_derived\_order\_thm) (inst\_type\_rule [(\PrJE{}ONE\PrKO{}, \PrJE{}'a\PrKO{})] gsu\_wftc\_thm2))]);\\
\+val wf\_CT\_lemma = pop\_thm ();\\
\+\\
\+val wf\_CT\_thm = save\_thm ("wf\_CT\_thm", rewrite\_rule [get\_spec \PrKM{}DerivedOrder\PrKO{}] wf\_CT\_lemma);\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}c1 c2\MMM{\bullet} CTrep c1 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2)\\
\+		\MMM{\land} CTrep c2 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2)\PrKO{});\\
\+a (REPEAT \MMM{\forall}\_tac THEN rewrite\_tac[\PrIJ{c}\_def]);\\
\+a (lemma\_tac \PrKM{}CTsyntax (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep c1 \MMM{\mapsto}\PrIJ{u} CTrep c2)\PrKO{} \\
\+	THEN1 (bc\_tac [\MMM{\land}\_right\_elim CTrepclosed\_CTsyntax\_thm]\\
\+		THEN rewrite\_tac [CTrep\_def]));\\
\+a (lemma\_tac \PrKM{}CTrep c1 \MMM{\mapsto}\PrIJ{u} CTrep c2 \MMM{\in}\PrIJ{u}\PrJL{+} Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep c1 \MMM{\mapsto}\PrIJ{u} CTrep c2\PrKO{}\\
\+	THEN1 rewrite\_tac[]);\\
\+a (lemma\_tac \PrKM{}CTrep c1 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep c1 \MMM{\mapsto}\PrIJ{u} CTrep c2 \MMM{\land} CTrep c2 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep c1 \MMM{\mapsto}\PrIJ{u} CTrep c2\PrKO{}\\
\+	THEN1 rewrite\_tac[]);\\
\+a (all\_asm\_fc\_tac [tc\MMM{\in}\PrIJ{u}\_trans\_thm]);\\
\+a (ALL\_FC\_T asm\_rewrite\_tac[CTrep\_def]);\\
\+val tc\MMM{\in}\PrIJ{u}\_rep\_\PrIJ{c}\_lemma = save\_pop\_thm "tc\MMM{\in}\PrIJ{u}\_rep\_\PrIJ{c}\_lemma";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}P\MMM{\bullet} (\MMM{\forall}n\MMM{\bullet} P (C n)) \MMM{\land} (\MMM{\forall}c c0\MMM{\bullet} P c \MMM{\land} P c0 \MMM{\Rightarrow} P (c \PrIJ{c} c0)) \MMM{\Rightarrow} \MMM{\forall}c\MMM{\bullet} P c\PrKO{});\\
\+a (REPEAT strip\_tac);\\
\+a (wf\_induction\_tac wf\_CT\_thm \PrKM{}c\PrKO{});\\
\+a (strip\_asm\_tac (\MMM{\forall}\_elim \PrKM{}t\PrKO{} CT\_cases)\\
\+	THEN asm\_rewrite\_tac[]);\\
\+a (var\_elim\_asm\_tac \PrKM{}t = c1 \PrIJ{c} c2\PrKO{});\\
\+a (POP\_ASM\_T (asm\_tac o (rewrite\_rule[])));\\
\+a (lemma\_tac \PrKM{}CTrep c1 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2) \MMM{\land} CTrep c2 \MMM{\in}\PrIJ{u}\PrJL{+} CTrep (c1 \PrIJ{c} c2)\PrKO{}\\
\+	THEN1 rewrite\_tac [tc\MMM{\in}\PrIJ{u}\_rep\_\PrIJ{c}\_lemma]);\\
\+a (all\_asm\_fc\_tac[]);\\
\+a (all\_asm\_fc\_tac[]);\\
\+val CT\_induction = save\_pop\_thm "CT\_induction";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}f0 f1\MMM{\bullet} \MMM{\exists}fn:ONE GSU \MMM{\rightarrow} 'a\MMM{\bullet}\\
\+	(\MMM{\forall}n\MMM{\bullet} fn (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n:ONE GSU) = f0 (Nat\PrIJ{u} n:ONE GSU))\\
\+	\MMM{\land} (\MMM{\forall}a0 a1\MMM{\bullet} fn (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} (a0 \MMM{\mapsto}\PrIJ{u} a1)) = f1 a0 a1 (fn a0) (fn a1))\PrKO{});\\
\+a (REPEAT strip\_tac);\\
\+a (lemma\_tac \PrKM{}\MMM{\exists}g\MMM{\bullet} g = \MMM{\lambda}fn (x:ONE GSU)\MMM{\bullet}\\
\+  if (\MMM{\exists}n\MMM{\bullet} x = (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} (Nat\PrIJ{u} n:ONE GSU))) \MMM{\lor} \MMM{\exists}a0 a1\MMM{\bullet} x = (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1)\\
\+  then\\
\+	if Fst\PrIJ{u} x = Nat\PrIJ{u} 0\\
\+	then f0 (Snd\PrIJ{u} x)\\
\+	else	let a0 = Fst\PrIJ{u} (Snd\PrIJ{u} x)\\
\+		and a1 = Snd\PrIJ{u} (Snd\PrIJ{u} x)\\
\+		in f1 a0 a1 (fn a0) (fn a1)\\
\+  else \MMM{\epsilon}x\MMM{\bullet} T\PrKO{}\\
\+	THEN1 prove\_\MMM{\exists}\_tac);\\
\+a (lemma\_tac \PrKM{}g respects \$\MMM{\in}\PrIJ{u}\PrKO{}\\
\+	THEN1 (rewrite\_tac [get\_spec \PrKM{}\$respects\PrKO{}]\\
\+		THEN REPEAT strip\_tac\\
\+		THEN asm\_rewrite\_tac[]));\\
\+(* *** Goal "1" *** *)\\
\+a (cond\_cases\_tac \PrKM{}Fst\PrIJ{u} x = Nat\PrIJ{u} 0\PrKO{});\\
\+a (CASES\_T \PrKM{}(\MMM{\exists}n\MMM{\bullet} x = (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} (Nat\PrIJ{u} n:ONE GSU))) \MMM{\lor} \MMM{\exists}a0 a1\MMM{\bullet} x = (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1)\PrKO{}\\
\+	(fn x => rewrite\_thm\_tac x THEN asm\_tac x));\\
\+a (POP\_ASM\_T strip\_asm\_tac);\\
\+(* *** Goal "1.1" *** *)\\
\+a (var\_elim\_asm\_tac \PrKM{}x = Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n\PrKO{});\\
\+a (POP\_ASM\_T (strip\_asm\_tac o (rewrite\_rule[])));\\
\+(* *** Goal "1.2" *** *)\\
\+a (lemma\_tac \PrKM{}tc \$\MMM{\in}\PrIJ{u} a0 x \MMM{\land} tc \$\MMM{\in}\PrIJ{u} a1 x\PrKO{}\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+(* *** Goal "1.2.1" *** *)\\
\+a (lemma\_tac \PrKM{}a0 \MMM{\in}\PrIJ{u}\PrJL{+} (a0 \MMM{\mapsto}\PrIJ{u} a1)\PrKO{} THEN1 asm\_rewrite\_tac[tc\MMM{\in}\PrIJ{u}\_\MMM{\mapsto}\PrIJ{u}\_left\_thm]);\\
\+a (lemma\_tac \PrKM{}(a0 \MMM{\mapsto}\PrIJ{u} a1) \MMM{\in}\PrIJ{u}\PrJL{+} (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} (a0 \MMM{\mapsto}\PrIJ{u} a1))\PrKO{}\\
\+	THEN1 asm\_rewrite\_tac[tc\MMM{\in}\PrIJ{u}\_\MMM{\mapsto}\PrIJ{u}\_right\_thm]);\\
\+a (LEMMA\_T \PrKM{}a0 \MMM{\in}\PrIJ{u}\PrJL{+} (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1)\PrKO{}\\
\+	(asm\_tac o (rewrite\_rule[get\_spec \PrKM{}\$\MMM{\in}\PrIJ{u}\PrJL{+}\PrKO{}]))\\
\+	THEN1 all\_fc\_tac [tc\MMM{\in}\PrIJ{u}\_trans\_thm]);\\
\+a (asm\_rewrite\_tac[]);\\
\+a (lemma\_tac \PrKM{}a1 \MMM{\in}\PrIJ{u}\PrJL{+} (a0 \MMM{\mapsto}\PrIJ{u} a1)\PrKO{} THEN1 asm\_rewrite\_tac[tc\MMM{\in}\PrIJ{u}\_\MMM{\mapsto}\PrIJ{u}\_left\_thm]);\\
\+a (LEMMA\_T \PrKM{}a1 \MMM{\in}\PrIJ{u}\PrJL{+} (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1)\PrKO{}\\
\+	(rewrite\_thm\_tac o (rewrite\_rule[get\_spec \PrKM{}\$\MMM{\in}\PrIJ{u}\PrJL{+}\PrKO{}]))\\
\+	THEN1 all\_fc\_tac [tc\MMM{\in}\PrIJ{u}\_trans\_thm]);\\
\+(* *** Goal "1.2.2" *** *)\\
\+a (all\_asm\_fc\_tac []);\\
\+a (REPEAT\_N 2 (POP\_ASM\_T ante\_tac) THEN asm\_rewrite\_tac[let\_def]);\\
\+a (REPEAT strip\_tac THEN asm\_rewrite\_tac[]);\\
\+(* *** Goal "2" *** *)\\
\+a (strip\_asm\_tac (inst\_type\_rule [(\PrJE{}ONE\PrKO{}, \PrJE{}'a\PrKO{})] gsu\_wf\_thm1));\\
\+a (all\_fc\_tac [fixp\_thm1]);\\
\+a (\MMM{\exists}\_tac \PrKM{}g'\PrKO{});\\
\+a (POP\_ASM\_T ante\_tac\\
\+	THEN once\_asm\_rewrite\_tac[]\\
\+	THEN rewrite\_tac[]\\
\+	THEN strip\_tac);\\
\+a (strip\_tac THEN REPEAT \MMM{\forall}\_tac);\\
\+(* *** Goal "2.1" *** *)\\
\+a (SPEC\_NTH\_ASM\_T 1 \PrKM{}Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} (Nat\PrIJ{u} n):ONE GSU\PrKO{} ante\_tac);\\
\+a (LEMMA\_T \PrKM{}\MMM{\exists} n'\MMM{\bullet} Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n = Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} n'\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 (\MMM{\exists}\_tac \PrKM{}n\PrKO{} THEN rewrite\_tac[]));\\
\+a (LEMMA\_T \PrKM{}\MMM{\exists} n'\MMM{\bullet} n = n'\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 (\MMM{\exists}\_tac \PrKM{}n\PrKO{} THEN rewrite\_tac[]));\\
\+a (STRIP\_T (rewrite\_thm\_tac o (eq\_sym\_rule)));\\
\+(* *** Goal "2.2" *** *)\\
\+a (SPEC\_NTH\_ASM\_T 1 \PrKM{}Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1:ONE GSU\PrKO{} ante\_tac);\\
\+a (LEMMA\_T \PrKM{}\MMM{\exists} a0' a1'\MMM{\bullet} Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0 \MMM{\mapsto}\PrIJ{u} a1 = Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} a0' \MMM{\mapsto}\PrIJ{u} a1'\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 (\MMM{\exists}\_tac \PrKM{}a0\PrKO{} THEN \MMM{\exists}\_tac \PrKM{}a1\PrKO{} THEN rewrite\_tac[]));\\
\+a (rewrite\_tac[let\_def]);\\
\+a (STRIP\_T (rewrite\_thm\_tac o (eq\_sym\_rule)));\\
\+val rec\_lemma1 = pop\_thm ();\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}f0 f1\MMM{\bullet}\\
\+         \MMM{\exists}fn: CT \MMM{\rightarrow} 'a\MMM{\bullet}\\
\+           (\MMM{\forall}a\MMM{\bullet} fn (C a) = f0 a) \MMM{\land}\\
\+           \MMM{\forall}a0 a1:CT\MMM{\bullet} (fn (a0 \PrIJ{c} a1):'a) = (f1 a0 a1 (fn a0) (fn a1))\PrKO{});\\
\+a (REPEAT strip\_tac);\\
\+a (strip\_asm\_tac (list\_\MMM{\forall}\_elim\\
\+	[\PrKM{}\MMM{\lambda}c:ONE GSU\MMM{\bullet} f0 (\MMM{\epsilon}n\MMM{\bullet} Nat\PrIJ{u} n = c)\PrKO{},\\
\+	\PrKM{}\MMM{\lambda}a0 a1 fa0 fa1\MMM{\bullet} f1 (CTabs a0) (CTabs a1) fa0 fa1\PrKO{}]\\
\+ rec\_lemma1));\\
\+a (\MMM{\exists}\_tac \PrKM{}\MMM{\lambda}c\MMM{\bullet} fn (CTrep c)\PrKO{}\\
\+	THEN REPEAT strip\_tac THEN\_TRY asm\_rewrite\_tac[CTrep\_def, C\_def, \PrIJ{c}\_def]);\\
\+(* *** Goal "1" *** *)\\
\+a (lemma\_tac \PrKM{}CTsyntax (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a)\PrKO{}\\
\+	THEN1 rewrite\_tac[CTrepclosed\_CTsyntax\_thm]);\\
\+a (FC\_T asm\_rewrite\_tac [CTrep\_def]);\\
\+a (\MMM{\epsilon}\_tac \PrKM{}\MMM{\epsilon} n\MMM{\bullet} n = a\PrKO{} THEN1 prove\_\MMM{\exists}\_tac);\\
\+a (asm\_rewrite\_tac[]);\\
\+(* *** Goal "2" *** *)\\
\+a (lemma\_tac \PrKM{}CTsyntax(CTrep a0) \MMM{\land} CTsyntax(CTrep a1)\PrKO{}\\
\+	THEN1 rewrite\_tac [CTrep\_def]);\\
\+a (lemma\_tac \PrKM{}CTsyntax(Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0 \MMM{\mapsto}\PrIJ{u} CTrep a1)\PrKO{}\\
\+	THEN1 all\_fc\_tac [CTrepclosed\_CTsyntax\_thm]);\\
\+a (ALL\_FC\_T asm\_rewrite\_tac [CTrep\_def]);\\
\+a (rewrite\_tac[CTrep\_def]);\\
\+val CT\_axiom = save\_pop\_thm "CT\_axiom";\\
\+\\
\+add\_\MMM{\exists}\_cd\_thms [CT\_axiom] "'icl";\\
\+set\_merge\_pcs ["misc31", "'icl"];\\
\end{GFT}
}%ignore

\subsection{Further Definitions}

We can now define constants over $CT$ by pattern matching primitive recursion.

I would normally obtain a `course of values' induction by defining a well-founded relation over the terms, which is easily done thus:

\begin{GFT}{SML}
\+declare\_infix(200, "in\PrIJ{c}");\\
\end{GFT}

\begin{HOLConst}
\+\PrNM{} \$\PrNL{}in\PrIJ{c}\PrNN{}: CT \MMM{\rightarrow} CT \MMM{\rightarrow} BOOL\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}x y\MMM{\bullet} x in\PrIJ{c} y \MMM{\Leftrightarrow} \MMM{\exists}z\MMM{\bullet} y = x \PrIJ{c} z \MMM{\lor} y = z \PrIJ{c} x\\
\end{HOLConst}


\begin{GFT}{}
\end{GFT}

\ignore{
\begin{GFT}{SML}
\+val in\PrIJ{c}\_def = get\_spec \PrKM{}\$in\PrIJ{c}\PrKO{};\\
\+\\
\end{GFT}
}%ignore

However, the method used in the hol4 datatype system is to define a numeric `size' for combinatory terms as follows:

\begin{HOLConst}
\+\PrNM{} \PrNL{}CT\_size\PrNN{}: CT \MMM{\rightarrow} \PrOO{}\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{}	(\MMM{\forall}a\MMM{\bullet}		CT\_size (C a)		= 1 + a)\\
\+\PrNM{} \MMM{\land}	\MMM{\forall}a0 a1\MMM{\bullet}	CT\_size (a0 \PrIJ{c} a1)	= 1 + CT\_size a0 + CT\_size a1\\
\end{HOLConst}

Course of values induction can then be obtained by induction over the size of combinatory terms.

\begin{HOLConst}
\+\PrNM{} \PrNL{}CT\_case\PrNN{}: (\PrOO{} \MMM{\rightarrow} CT) \MMM{\rightarrow} (CT \MMM{\rightarrow} CT \MMM{\rightarrow} CT) \MMM{\rightarrow} (CT \MMM{\rightarrow} CT)\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}f g x y n\MMM{\bullet}	CT\_case f g (C n) = f n\\
\+\PrNM{}		\MMM{\land}	CT\_case f g (x \PrIJ{c} y) = g x y\\
\end{HOLConst}

\ignore{
\begin{GFT}{SML}
\+val CT\_case\_def = get\_spec \PrKM{}CT\_case\PrKO{};\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\exists}CT\_size2\MMM{\bullet} (\MMM{\forall}a\MMM{\bullet}	CT\_size2 (C a)	= 1 + a)\\
\+\PrNM{} \MMM{\land}	\MMM{\forall}a0 a1\MMM{\bullet}	CT\_size2 (a0 \PrIJ{c} a1)	= 1 + CT\_size2 a0 + CT\_size2 a1\PrKO{});\\
\+a (strip\_asm\_tac (list\_\MMM{\forall}\_elim\\
\+	[\PrKM{}\MMM{\lambda}a:\PrOO{}\MMM{\bullet} 1 + a\PrKO{}, \PrKM{}\MMM{\lambda}(a0:CT) (a1:CT) fa0 fa1\MMM{\bullet} 1 + fa0 + fa1\PrKO{}] CT\_axiom));\\
\+\\
\+set\_flag("pp\_show\_HOL\_types", false);\\
\end{GFT}
}%ignore

We now prove the rest of the theorems which are derived automatically for the datatype in hol4.

\begin{GFT}{}
\+\PrNL{}CT\_11\PrNN{} =\\
\+	\MMM{\Zthm} (\MMM{\forall} a a'\MMM{\bullet} C a = C a' \MMM{\Rightarrow} a = a')\\
\+	\MMM{\land} (\MMM{\forall} a0 a1 a0' a1'\MMM{\bullet} a0 \PrIJ{c} a1 = a0' \PrIJ{c} a1' \MMM{\Rightarrow} a0 = a0' \MMM{\land} a1 = a1')\\
\+\PrNL{}CT\_distinct\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} a a0 a1\MMM{\bullet} \MMM{\lnot} C a = a0 \PrIJ{c} a1\\
\+\PrNL{}CT\_nchotomy\PrNN{} =\\
\+	\MMM{\Zthm} \MMM{\forall} cc\MMM{\bullet} \MMM{\lnot} ((\MMM{\exists} n\MMM{\bullet} cc = C n) \MMM{\Leftrightarrow} (\MMM{\exists} c c0\MMM{\bullet} cc = c \PrIJ{c} c0))\\
\end{GFT}


\ignore{
\begin{GFT}{SML}
\+set\_goal([], \PrKM{}\\
\+	(\MMM{\forall}a a'\MMM{\bullet} (C a = C a') \MMM{\Rightarrow} (a = a')) \MMM{\land}\\
\+        (\MMM{\forall}a0 a1 a0' a1'\MMM{\bullet} (a0 \PrIJ{c} a1 = a0' \PrIJ{c} a1') \MMM{\Rightarrow} (a0 = a0') \MMM{\land} (a1 = a1'))\\
\+\PrKO{});\\
\+a (rewrite\_tac [C\_def, \PrIJ{c}\_def] THEN REPEAT\_N 2 strip\_tac\\
\+	THEN REPEAT \MMM{\forall}\_tac THEN strip\_tac);\\
\+(* *** Goal "1" *** *)\\
\+a (lemma\_tac \PrKM{}CTsyntax(Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a)\PrKO{} THEN1 rewrite\_tac [CTrepclosed\_CTsyntax\_thm]);\\
\+a (lemma\_tac \PrKM{}CTsyntax(Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a')\PrKO{} THEN1 rewrite\_tac [CTrepclosed\_CTsyntax\_thm]);\\
\+a (LEMMA\_T \PrKM{}CTrep(CTabs (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a)) = CTrep(CTabs (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a'))\PrKO{} (fn y => ALL\_FC\_T (fn x => (asm\_tac o (rewrite\_rule x)) y) [CTrep\_def])\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+a (strip\_tac);\\
\+(* *** Goal "2" *** *)\\
\+a (lemma\_tac \PrKM{}CTsyntax(CTrep a0) \MMM{\land} CTsyntax(CTrep a1)\PrKO{}\\
\+	THEN1 rewrite\_tac [CTrep\_def]);\\
\+a ((lemma\_tac \PrKM{}CTsyntax (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0 \MMM{\mapsto}\PrIJ{u} CTrep a1)\PrKO{}\\
\+	THEN1 (bc\_tac [\MMM{\land}\_right\_elim CTrepclosed\_CTsyntax\_thm]))\\
\+		THEN\_TRY ALL\_FC\_T asm\_rewrite\_tac [CTrep\_def]);\\
\+a (lemma\_tac \PrKM{}CTsyntax(CTrep a0') \MMM{\land} CTsyntax(CTrep a1')\PrKO{}\\
\+	THEN1 rewrite\_tac [CTrep\_def]);\\
\+a ((lemma\_tac \PrKM{}CTsyntax (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0' \MMM{\mapsto}\PrIJ{u} CTrep a1')\PrKO{}\\
\+	THEN1 (bc\_tac [\MMM{\land}\_right\_elim CTrepclosed\_CTsyntax\_thm]))\\
\+		THEN\_TRY ALL\_FC\_T asm\_rewrite\_tac [CTrep\_def]);\\
\+a (LEMMA\_T \PrKM{}CTrep(CTabs (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0 \MMM{\mapsto}\PrIJ{u} CTrep a1))\\
\+             = CTrep(CTabs (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0' \MMM{\mapsto}\PrIJ{u} CTrep a1'))\PrKO{}\\
\+	(fn y => ALL\_FC\_T (fn x => (ante\_tac o (try(rewrite\_rule x))) y) [CTrep\_def])\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+a (strip\_tac THEN LEMMA\_T\\
\+	\PrKM{}CTabs(CTrep a0) = CTabs(CTrep a0')\\
\+	\MMM{\land} CTabs(CTrep a1) = CTabs(CTrep a1')\PrKO{}\\
\+	(rewrite\_thm\_tac o (rewrite\_rule [CTrep\_def]))\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+val CT\_11 = save\_pop\_thm "CT\_11";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}a a0 a1\MMM{\bullet} \MMM{\lnot} C a = a0 \PrIJ{c} a1\PrKO{});\\
\+a (rewrite\_tac [C\_def, \PrIJ{c}\_def] THEN contr\_tac);\\
\+a (lemma\_tac \PrKM{}CTsyntax(CTrep a0) \MMM{\land} CTsyntax(CTrep a1)\PrKO{}\\
\+	THEN1 rewrite\_tac [CTrep\_def]);\\
\+a ((lemma\_tac \PrKM{}CTsyntax (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0 \MMM{\mapsto}\PrIJ{u} CTrep a1)\PrKO{}\\
\+	THEN1 (bc\_tac [\MMM{\land}\_right\_elim CTrepclosed\_CTsyntax\_thm]))\\
\+		THEN\_TRY ALL\_FC\_T asm\_rewrite\_tac [CTrep\_def]);\\
\+a (lemma\_tac \PrKM{}CTsyntax(Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a)\PrKO{}\\
\+	THEN1 (rewrite\_tac [CTrepclosed\_CTsyntax\_thm]));\\
\+a (LEMMA\_T \PrKM{}CTrep(CTabs (Nat\PrIJ{u} 0 \MMM{\mapsto}\PrIJ{u} Nat\PrIJ{u} a))\\
\+	= CTrep(CTabs (Nat\PrIJ{u} 1 \MMM{\mapsto}\PrIJ{u} CTrep a0 \MMM{\mapsto}\PrIJ{u} CTrep a1))\PrKO{}\\
\+	ante\_tac\\
\+	THEN1 asm\_rewrite\_tac[]);\\
\+a (FC\_T rewrite\_tac [CTrep\_def]);\\
\+val CT\_distinct = save\_pop\_thm "CT\_distinct";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}M M' f f1\MMM{\bullet}\\
\+         (M = M') \MMM{\land} (\MMM{\forall}a\MMM{\bullet} (M' = C a) \MMM{\Rightarrow} (f a = f' a)) \MMM{\land}\\
\+         (\MMM{\forall}a0 a1\MMM{\bullet} (M' = a0 \PrIJ{c} a1) \MMM{\Rightarrow} (f1 a0 a1 = f1' a0 a1)) \MMM{\Rightarrow}\\
\+         (CT\_case f f1 M = CT\_case f' f1' M')\PrKO{});\\
\+a (REPEAT \MMM{\forall}\_tac\\
\+	THEN REPEAT strip\_tac\\
\+	THEN asm\_rewrite\_tac[]);\\
\+a (strip\_asm\_tac (\MMM{\forall}\_elim \PrKM{}M'\PrKO{} CT\_cases)\\
\+	THEN asm\_rewrite\_tac[CT\_case\_def]\\
\+	THEN GET\_NTH\_ASM\_T 1 (var\_elim\_asm\_tac o concl));\\
\+(* *** Goal "1" *** *)\\
\+a (spec\_nth\_asm\_tac 2 \PrKM{}n\PrKO{});\\
\+(* *** Goal "2" *** *)\\
\+a (var\_elim\_asm\_tac \PrKM{}M = c1 \PrIJ{c} c2\PrKO{});\\
\+a (list\_spec\_nth\_asm\_tac 1 [\PrKM{}c1\PrKO{}, \PrKM{}c2\PrKO{}]);\\
\+val CT\_case\_cong = save\_pop\_thm "CT\_case\_cong";\\
\+\\
\+set\_goal([], \PrKM{}\MMM{\forall}cc\MMM{\bullet} \MMM{\lnot} (\MMM{\exists}n\MMM{\bullet} cc = C n) = (\MMM{\exists}c c0\MMM{\bullet} cc = c \PrIJ{c} c0)\PrKO{});\\
\+a (REPEAT \MMM{\forall}\_tac);\\
\+a (strip\_asm\_tac (\MMM{\forall}\_elim \PrKM{}cc\PrKO{} CT\_cases) THEN asm\_rewrite\_tac [CT\_distinct]);\\
\+(* *** Goal "1" *** *)\\
\+a (\MMM{\exists}\_tac \PrKM{}n\PrKO{} THEN asm\_rewrite\_tac[]);\\
\+(* *** Goal "2" *** *)\\
\+a (LEMMA\_T \PrKM{}\MMM{\forall} a a0 a1\MMM{\bullet} \MMM{\lnot} a0 \PrIJ{c} a1 = C a\PrKO{} rewrite\_thm\_tac\\
\+	THEN1 (REPEAT strip\_tac THEN\_TRY rewrite\_tac[CT\_distinct]));\\
\+(* *** Goal "2.1" *** *)\\
\+a (rewrite\_tac [map\_eq\_sym\_rule (all\_\MMM{\forall}\_elim CT\_distinct)]);\\
\+(* *** Goal "2.2" *** *)\\
\+a (\MMM{\exists}\_tac \PrKM{}c1\PrKO{} THEN \MMM{\exists}\_tac \PrKM{}c2\PrKO{} THEN asm\_rewrite\_tac[]);\\
\+val CT\_nchotomy = save\_pop\_thm "CT\_nchotomy";\\
\end{GFT}
}%ignore

\subsection{Combinator Names}

In the original hol4 treatment the combinators K and S were constructors of the abstract datatype.
In this quasi replica I made the minor generalisation of allowing countably many constants using a constructor taking a natural number parameter.

To make the material more legible I now define constants to give the conventional names to the S and K constructors as follows.

\begin{HOLConst}
\+\PrNM{} \PrNL{}K\PrIJ{c}\PrNN{}: CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{}	K\PrIJ{c} = C 0\\
\end{HOLConst}

\begin{HOLConst}
\+\PrNM{} \PrNL{}S\PrIJ{c}\PrNN{}: CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{}	S\PrIJ{c} = C 1\\
\end{HOLConst}

Once I have replicated essentially the same Church Rosser proof for this pure combinatory logic I will then attempt a proof for an illative system with one illative combinatory.
This will be called `Q'.

\begin{HOLConst}
\+\PrNM{} \PrNL{}Q\PrIJ{c}\PrNN{}: CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{}	Q\PrIJ{c} = C 2\\
\end{HOLConst}

Since `Q' is intended to be a close approximation to equality, it might be nice to have the following way of writing equations:

\begin{GFT}{SML}
\+declare\_infix(300, "=\PrIJ{c}");\\
\end{GFT}


\begin{HOLConst}
\+\PrNM{} \$\PrNL{}=\PrIJ{c}\PrNN{}: CT \MMM{\rightarrow} CT \MMM{\rightarrow} CT\\
\PrPH{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}\PrPM{}
\+\PrNM{} \MMM{\forall}a0 a1\MMM{\bullet} a0 =\PrIJ{c} a1 = (Q\PrIJ{c} \PrIJ{c} a0) \PrIJ{c} a1\\
\end{HOLConst}

This kind of equality delivers a combinatory term rather than a BOOL.
True and false will probably be coded as left and right projections, i.e. K and KI (where I is the identity, which is SKK).

These definitions really only give names to the combinators, to know what they mean you have to look at the reduction relations over the combinators.

\begin{GFT}{SML}
\+set\_flag ("subgoal\_package\_quiet", false);\\
\+set\_flag ("pp\_use\_alias", true);\\
\end{GFT}



