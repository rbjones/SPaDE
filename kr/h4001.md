# The SPaDE Knowledge Repository

In this document a formal specification in HOL of the abstract structure of the SPaDE Knowledge Repository is presented.
Separate documentation is available describing the structure of SPaDE native repository as stored on persistent media.

The knowledge repository is a versioned collection of logical contexts, each determining the type and meaning of a collection of names, the signficance of which may vary from one `context' to another.

A context is sometimes best thought of as a *theory*, sometimes may be thought of as an abstract *language*.
Thus, for example, a theory of ordered pairs might be developed in a context whose signature includes a polymorphic operator for creating ordered pairs, and projections for extracting the left and right elements from such a pair, with constraints which ensure that these operators combine in the required way.

By contrast, for reasoning about the correctness of programs one might construct a context in which operators are available whose signature corresponds with the abstract syntax of the relevant programming language, and whose definitions capture the semantics of the language, thus providing for the representation in HOL of programs in that language.
In that case we may see the context as establishing a language, and also sufficient metatheory to reason about programs expressed in that language.

More generally, in using formal models of some engineering domain for the purpose of achieving reliable design and implementation of softare and hardware systems in that domain, the context in which that design activity takes place constitutes a language in which the necessary features of the designed systems and their role in the domain can be expressed.

Each such context is created, from a primitive context which corresponds to the primitive HOL logical system, by extensions, usually *conservative*.
Each such extension introduces names for new type constructors and/or constants, together with a constraint limiting the values which those names can take, and optionally but normally, a proven existential theorem showing that every model of the prior context can be extended to encompass these new types and constants in a way which satisfies the constraints.

There may also be provision in the repository for the storage of theorems proven in each of these contexts, though in SPaDE, the close coupling between theories and theorems proven in those theories is relaxed, and theorem caching will be undertaken in more diverse ways by domain specific specialists.

Because the repository as a whole is intended to be widely distributed, we arrange for uniqueness of names across the repository by means similar to those used to ensure that URL's uniquely refer to their targets.
In SPaDE however, no presumption about the height and width of the hierarchy are made, allowing indefinite extension as the solar, system, galaxy and cosmos are explored.
This is accomplished by the additional provision that names are always *relative* and the top is open ended, enabling any two repositories from disparate origins to be logically combined into a single repository by adding an additional layer if necessary.

The localisation of names requires a hierarchical "directory" structure (though not all the structures which support this need be called directories) in which *theories* are the lowest level and serve to define the constants which characterise any particular subject matter.
This hierarchy of directories or folders ensures that all names are unique, and hence, if characterised by conservative means, can all be gathered together into a single consistent context.

However, it will not be normal or desirable to be working in such a maximal context, and the use of focal AI methods to support reasoning will require that the context in which reasoning takes place is carefully curated to include only those names which are relevant to the subject matter at hand.
This is achieved by a distinct hierarchy among the theories which is determined by the ancestry of theories, each theory being formed by extension of one or more prior theories, which may be called its *parents*.

Thus we see that the repository consists of a suitably indexed collection of HOL signatures and constraining formulae which give meaning to the names in the signatures, and the first part of this specification is therefore concerned with the abstract syntax of HOL.

There are two distinct structures to a repository, the first created by the structure of the names, the second by the operations on contexts, which creates a relationship of inclusion between contexts.

Its structure is therefore:

- names
- types
- terms and sequents
- operators on contexts
- polymorphic versioned trees
- the tree of versioned contexts
- the tree of theorems in context

Apart from some additional features not yet touched upon, notably the use of checksums for integrity and digital signatures endorsing theorems, this covers the structure of a repository.
Theorem proving will always take place in exactly one logical context, and access to the repository for that purpose will require the extraction of the content of the relevant context.

## Preliminaries

```sml
app load ["bossLib", "stringTheory"];
open bossLib Theory Parse;
local open stringTheory pred_setTheory in end;
val _ = new_theory "HOLterms";
```

## S-expressions

Underlying the HOL structures in SPaDE native repositories there is replica of the LISP S-expression structure, which is a simple binary tree structure in which each node is either an atom or a pair of nodes.

This is mentioned here not because of its role in the representation of terms in the repository, but because it is used here for the structure of literal terms, which are explicit constants whose value is given by their structure as an S-expression.

```sml
Datatype: sexp =
      Atom string
    | Nil
    | Cons sexp sexp
End
```

## Names

Names are relative giving a place in the heirarchic structure relative to some given place.
They are therefore represented as a number indicating a height above the current folder, and a path downward from that folder.
Each stage selects a new folder, the last of which will be a theory.

```sml
val _ = Datatype `sname = Sn string`;
val _ = Datatype `rname = Rn num (sname list)`;
```

## Hashes

A signed cryptographic hash is a byte sequence, represented as a string (i.e. an arbitrary byte sequence).

```sml
val _ = Datatype `shash = Sh string`;
```

## Types

```sml
val _ = Datatype
        `htype = Tyv sname
               | Tyc rname (htype list)`;
```

## Terms

Because names are relative, comparing constants in terms is complicated by the possibility of using constants in distinct contexts, and the need to adjust to a common context.
There are several ways to approach this difficulty, and a final decision may not be made until prototyping is well progressed.
Meanwhile provision is made in this specification for terms to be relocated.

In the following we have the normal four kinds of term, variables, constants, applications and abstractions, with the addition of a term relocator.

```sml
val _ = Datatype
      `hterm = Tmv sname
             | Tmc rname htype
             | Tapp hterm hterm
             | Tabs sname htype hterm
             | Tloc rname hterm
             | Tlit sexp;             
```

## Sequents

```sml
val _ = Datatype
      `hsequent = Sg (hterm list) hterm`;
```

## Signature

```sml
Datatype: hsig =
      <| types: (rname # num)list;
         constants: (rname # htype)list
      |>
End
```

## Extension

```sml
Datatype: hext =
      <| signature: hsig;
         constraint: hterm
      |>
End
```

## Theory

```sml
Datatype: htheory =
      <| thname: sname;
         parents: rname list # shash;
         extensions: hext list;
         shash: shash
      |>
End
```

## Folders

Folders are used to structure the repository hierarchically, and contain theories or other folders.

```sml
val _ = Datatype `folder = Rdict (((num + sname) # 'b) list)`;
```

## Trees

I was looking for a much tighter charactersation of versioned trees, but this involved recursions in Datatype constructions which are not supported.
So this is a simpler tree datatype which will suffice.

```sml
val _ = Datatype
 `rtree =
   Rfolder (rtree rdict)   |
   Rleaf 'a`;
```

## The Repository

```sml
val _ = Datatype `hrepo = Hrepo (htheory rtree)`;
```
