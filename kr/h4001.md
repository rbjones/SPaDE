# The SPaDE Knowledge Repository

In this document a formal specification in HOL of the abstract structure of the SPaDE Knowledge Repository is presented.

The knowledge repository is a versioned collection of logical contexts, each determining the type and meaning of a collection of names, the signficance of which may vary from one `context' to another.

A context sometimes best thought of as a *theory*, sometimes best thought of as an abstract *language*.
Thus for example, a theory of ordered pairs might be developed in a context whose signature includes a polymorphic operator for creating ordered pairs, and projections for extracting the left and right elements from such a pair, with constraints which ensure that these operators combine in the required way.

By contrast, for reasoning about the correctness of programs one might construct a context in which operators are available whose signature corresponds with the abstract syntax of the language, and whose definitions capture the semantics of the language, thus providing for the representation in HOL of programs in that language.

More generally, in using formal models of some engineering domain for the purpose of achieving reliable design and implementation of softare and hardware systems in that domain, the context in which that design activity takes place constitutes a language in which the necessary features of the designed systems and their role in the domain can be expressed.

Each such context is created from a primitive context which corresponds to the primitive HOL logical system by extensions, usually *conservative*.
Each such extension introduces names for new type constructors and/or constants, together with a constraint limiting the values which those names can take, and optionally but normally, a proven existential theorem showing that every model of the prior context can be extended to encompass these new types and constants in a way which satisfies the constraints.

There may also be provision in the repository for the storage of theorems proven in each of these contexts.

Because the repository as a whole is intended to be widely distributed, we arrange for uniqueness of names across the repository by means similar to those used to ensure uniqueness of referent of URLs, with the additional provision that the name are always relative and the top is open ended, enabling any two repositories from disparate origins to be logically combined into a single repository by adding an additional layer if necessary.

The localisation of names, requires something like a hierarchical directory structure, whose relationship with theories remains at this stage not entirely determined (but possibly a theory will be a "leaf directory", i.e. a directory without subdirectories).
In order to maintain integrity contexts must never change, and are therefore versioned, so that in effect a change creates a new name.

Thus we see that the repository consists of a suitably indexed collection of HOL signatures and formulae (some constraints, some theorems), and the first part of this specification is therefore concerned with the abstract syntax of HOL.

There are two distinct structures to a repository, the first created by the structure of the names, the second by the operations on contexts, which creates a relationship of inclusion between contexts.

Its structure is therefore:

- names
- types
- terms and sequents
- operators on contexts
- polymorphic versioned trees
- the tree of versioned contexts
- the tree of theorems in context

Apart from some additional features not yet touched upon, notably the use of checksums for integrity and digital signatures endorsing theorems, this covers the structure of a repository.
Theorem proving will always take place in exactly one logical context, and access to the repository for that purpose will require the extraction of the content of the relevant context.

## Preliminaries

```sml
app load ["bossLib", "stringTheory"];
open bossLib Theory Parse;
local open stringTheory pred_setTheory in end;
val _ = new_theory "HOLterms";
```

## Names

Names are relative giving a place in the heirarchic structure relative to some given place.
They are therefore represented as a number indicating a height above the current folder, and a path downward from that folder.
Each stage selects a new folder, the last of which will usually be a theory, but each step is versioned, so a name/number pair is required, and the whole relative reference requires a list of such selections.

```sml
val _ = Datatype `sname = Sn string`;
val _ = Datatype `rname = Rn num ((sname # num) list)`;
```

## Types

```sml
val _ = Datatype
        `htype = Tyv sname
               | Tyc rname (htype list)`;
```

## Terms

Because names are relative, comparing constants in terms is complicated by the possibility of using constants in distinct contexts, and the need to adjust to a common context.
There are several ways to approach this difficulty, and a decision will probably not be made until prototyping is well progressed.
Meanwhile provision is made in this specification for terms to be relocated.

In the following we have the normal four kinds of term, variables, constants, applications and abstractions, with the addition of a term relocator.

```sml
val _ = Datatype
      `hterm = Tmv sname
             | Tmc rname htype
             | Tapp hterm hterm
             | Tabs sname htype hterm
             | Tloc rname hterm`;             
```

## Sequents

```sml
val _ = Datatype
      `hsequent = Sg (hterm list) hterm`;
```

## Signature

```sml
Datatype: hsig =
      <| types: (rname # num)list;
         constants: (rname # htype)list
      |>
End
```

## Extension

```sml
Datatype: hext =
      <| signature: hsig;
         constraint: hterm
      |>
End
```

## Theory

```sml
Datatype: htheory =
      <| thname: sname;
         parents: rname list;
         extensions: hext list
      |>
End
```

## Dictionary

In this dictionary ('a) rdict is a dictionary of 'a indexed by (num + sname).

```sml
val _ = Datatype `rdict = Rdict (((num + sname) # 'b) list)`;
```

## Trees

I was looking for a much tighter charactersation of versioned trees, but this involved recursions in Datatype constructions which are not supported.
So this is a simpler tree datatype which will suffice.

```sml
val _ = Datatype
 `rtree =
   Rfolder (rtree rdict)   |
   Rleaf 'a`;
```

## The Repository

```sml
val _ = Datatype `hrepo = Hrepo (htheory rtree)`;
```
